# Monad tutorial
:template lua
:pub Zl1PP3
:blurb My neighbour Totorial.

You know what they say: You can't become proficient in Lua without understanding monads.

I guess I think of a monad as some structure you can slap onto another type. If the another type is a type of number, then you can have monady things like list of numbers or maybe a number.

Some of the typical ones are pretty data structurey, but I think that in general it's more like some spacetime structure? Like lists and maybes are pretty spacey, but you can also have something like a promise of a number, which is like sure, there's data structure, but it's also like "maybe a number _later_" which uh has to do with time.

Whatever. You need a way to turn a value of the type you're slapping the monad onto into a value of the monad type. Like:

* Something that takes e.g. a number and gives you a list with one value that is that number
* Something that takes e.g. a number and gives you a maybe-value with that number present
* Something that takes e.g. a number and gives you a promise where the promised number is like there and also that number

And you need the bindy flatmappy thing:

* Something that takes a list of numbers and a function from a number to a list of numbers, and gives you a list of numbers
* And so on

Blah blah. I'm most certainly not doing promise stuff, but the others are fine:

``` run
function p(o)
  print(type(o) == "table" and table.concat(o, ", ") or o)
end

List = {}
function List.unit(x) return { x } end
function List.bind(list, f)
  local res = {}
  for _, old in ipairs(list) do
    for _, new in ipairs(f(old)) do
      table.insert(res, new)
    end
  end
  return res
end

Maybe = {}
function Maybe.unit(x) return { x } end
function Maybe.bind(maybe, f)
  return maybe[1] and f(maybe[1]) or {}
end
```

If you have _only_ the "monad interface" operations, lists and options would both just be containers that always had one element. Very uninteresting and not much fun:

``` repl
local l = List.unit(2)
p(l)
local l2 = List.bind(l, function(n) return List.unit(n + n) end)
p(l2)

local m = Maybe.unit(3)
p(m)
local m2 = Maybe.bind(m, function(n) return Maybe.unit(n * n) end)
p(m2)
```

Something like: The "monad interface" stuff is some stuff that e.g. lists and maybes have in common and it's also stuff that is incredibly useless on its own. The different monads better have other stuff you can do with them that is not part of the "monad interface." Stuff like:

* You have like ways of making empty lists and larger lists and stuff
* You can make a maybe with _no_ value
* You can whatever something or other with a promise I guess?

``` run
function List.of(...) return { ... } end

Maybe.nope = {}
function Maybe.orelse(m, v) return m[1] or v end
```

So now things are more okay:

``` repl
local function div(a, b)
  return b == 0 and Maybe.nope or Maybe.unit(a // b)
end

p(Maybe.orelse(div(7, 3), "nope"))
p(Maybe.orelse(div(7, 0), "nope"))

local l = List.of(1, 3, 5, 8)
p(List.bind(l, function(n) return List.of(n, n + n) end))
```

OKAY VERY GOOD. GREAT.

And like then I guess you can write some stuff in terms of the "monad interface" and have it work with whichever:

``` repl
local function foo(monad, m)
  return monad.bind(m, function(n) return monad.unit(n + n) end)
end

p(foo(Maybe, Maybe.nope))
p(foo(Maybe, Maybe.unit(5)))
p(foo(List, List.of(1, 2, 3)))
```

And be like ooh, it worked on both lists and maybes! It's not very impressive so you might have to say ooh several times.

Or like:

``` repl
local function map(monad, m, f)
  return monad.bind(
    m,
    function(x) return monad.unit(f(x)) end)
end
local function f(n) return n + n end

p(map(Maybe, Maybe.nope, f))
p(map(Maybe, Maybe.unit(5), f))
p(map(List, List.of(1, 2, 3), f))
```

Oh well.

## The IO monad

Okay so in Haskell, if you wanna make an application, you don't normally "write a program," but instead write a plugin for the Haskell framework. The Haskell framework uses the plugin to set up callbacks into your code and stuff. I imagine this is familiar stuff for people who know Angular and Spring and such. Plugins are values of the IO type. Here's an IO:

``` run
IO = {}
function IO.unit(x) return { io = "value", value = x } end
function IO.putstr(str) return { io = "putstr", str = str } end
IO.getline = { io = "getline" }
function IO.bind(m, f) return { io = "bound", first = m, f = f } end
```

Again: The `unit` thing is probably the least interesting. Bind is okay. But like an important thing is that there are these _other_ ways to get IO values as well. In this case `putstr` and  `getline`.

Here's a framework:

``` run
function framework(plugin)
  if plugin.io == "value" then
    return plugin.value
  elseif plugin.io == "putstr" then
    print(plugin.str)
    return nil
  elseif plugin.io == "getline" then
    return web.read()
  elseif plugin.io == "bound" then
    local first = framework(plugin.first)
    framework(plugin.f(first))
  end
end
```

Let's ^https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/ pretend that people have two names^ and write a plugin for asking about someone's names and then greeting them:

``` repl
local plugin = IO.bind(
  IO.putstr("What is your first name?"),
  function()
    return IO.bind(
      IO.getline,
      function(first)
        return IO.bind(
          IO.putstr("What is your last name?"),
          function()
            return IO.bind(
              IO.getline,
              function(last)
                return IO.putstr("Hi, " .. first .. " " .. last .. " :)")
              end)
          end)
      end)
  end)

framework(plugin)
```

So convenient :)

So like our plugin code never actually called the side-effecting things, `print` and `web.read`, itself. It just returned values that described what it needed done, along with callbacks, and let the framework deal with that side of things.

No idea why you'd want to syntactically sugar any of that, but some people `do`.
