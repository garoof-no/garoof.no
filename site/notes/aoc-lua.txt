# Some Advent of Code Lua
:pub ZkE3Ob
:blurb Lua uf advent.
:template lua

A few notes to self, in case I'm looking for previous stuff to copypaste in some future december or something...

I like Lua, it's smol. When I AoC with Lua I usually make pretty self-contained programs that only depend on the plain and regular Lua implementation and its standard library.

^https://lua.garoof.no/?code=DYewxghsAEBmB2EC2BTAUAS1tA7igRtAC4AWK8a0uBAdERkcCgBQBEAgiAMLT4ooAHXiBADWASkpxEqaAF5orDPAEBXIqyl58NWBibMEyFJJTAAzuipHZCiACcA5tAjwAJi6cBtAIwBdNHI3NDRQSBhsAB4wUEsAPnlpYxd3aAwQGlFyQxkTELCoOFV4MHoQeGhzIlVYZmBlPKoCmHsUc0SfKVgQexcAGl40ivr4FAAuRyQIIjASNgBSZmZ5twBqcWhlt3F58QloNxApKlb2hVPoACpNonLVJD57ZggN1eI7h5Qn-HFJKiCpK1qvYKqdAu58uBCrBiqV0hVzCBgAA3FgjNp-aDNaAXBQABi6PSxDSGxNG7UOxxxbUSpzeVRqdQamIBJxQwNBbXBwVCUJgKAAHsgBEwqr0FF4vGhmD4AEzQWUbZgAZmgyskzAALNAAKyapUANgNuqVAHZoKaNeaABySPwBNACezKIhsHAMEjQQXCphjCSO53wV2IlEsb1IEVtIj2CZTGZzVheAB6AB14H5VhJfphsNhSOQpE6XWw0+7SHB9CghmoiH7MUWg8wQ6jDGN0eZmL9TBCgA Here's some example code.^ It does the file stuff that usually needs to be done and the "works in the browser as well" thing.

If not line by line: Possibly `f:read("*all")` instead of `f:lines()`.

## Strings, matching, ...

``` run
function foldl(f, acc, list)
  for _, v in ipairs(list) do
    acc = f(acc, v)
  end
  return acc
end
```

Cataphatically matching on and grabbing what I want is often preferable to apophatically splitting on what I don't want.

If I e.g. have a line of input like `"123: 54 34 12"` and I need to do one thing with the number before the `:` and one thing with the rest of the numbers. I typically ignore the `:` and just `gmatch` to get the numbers:

``` repl
local line = "123: 25 34 12"

local nums = line:gmatch("%d+")
local first = tonumber(nums())
local rest = {}
for n in nums do table.insert(rest, tonumber(n)) end

print(foldl(function(a, b) return a + b end, first, rest))
print(foldl(function(a, b) return a - b end, first, rest))
```

If there had been a varying number of numbers _before_ the `:` I'd probably match and grab the before and after pieces before doing work on those:

``` repl
local line = "123 456: 25 34 12"
local before, after = line:match("(.*):(.*)")
print('do things, maybe some gmatch stuff, with "' .. before .. '" and "' .. after .. '"')
```

^https://www.lua.org/manual/5.4/manual.html#6.4.1 This area of the Lua manual^ is sometimes handy.

When I _do_ need to deal with `string.find`, it returns start index and stop index if it finds. Sometimes I wanna pass those on to `string.sub`. Sometimes I wanna keep finding from the stop index + 1.

## 2D maps and vectors

If I want to e.g. use x,y-positions as keys in a table, for each unique unique x,y-value there is only one table. "Constructing" the same position twice gives me two references to the same table, and not two tables with equal x and y values:

``` run
vecs = setmetatable({}, { __mode = "v" })
Vec = {}

function vec(x, y)
  local key = x .. "," .. y
  local found = vecs[key]
  if found then return found end
  local v = setmetatable({ x = x, y = y}, Vec)
  vecs[key] = v
  return v
end
```

See also: ^https://www.lua.org/pil/17.1.html Programming in Lua: 17.1 – Memoize Functions^.

The "weak" stuff (`__mode = "v"`) is not usually important particularly important for AoC stuff.

I typically use vectors for positions and also for directions. Som stuf:

``` run
function Vec.__add(a, b) return vec(a.x + b.x, a.y + b.y) end
function Vec.__tostring(a) return a.x .. "," .. a.y end

N, E, S, W = vec(0, -1), vec(1, 0), vec(0, 1), vec(-1, 0)
dirs = { N, E, S, W }

N.right = E ; E.right = S ; S.right = W ; W.right = N
N.left = W ; W.left = S ; S.left = E ; E.left = N


NW, NE, SE, SW = N + W, N + E, S + E, S + W
dirs = { NW, N, NE, E, SE, S, SW, W }
```

And then things like these might happen:

``` run
function mappy(lines)
  local map = {}
  local w = 1
  local y = 0
  for line in lines do
    y = y + 1
    local x = 0
    for c in line:gmatch(".") do
      x = x + 1
      map[vec(x, y)] = c
    end
    w = math.max(w, x)
  end
  map.size = vec(w, y)
  return map
end

function printmap(map)
  print(map.size)
  for y = 1, map.size.y do
    for x = 1, map.size.x do
      io.write(map[vec(x, y)] or " ")
    end
    io.write("\n")
  end
end

```

``` repl
local example = [[
qweqweqwe
asdasdasd
dsfsdfdsf
]]

local map = mappy(example:gmatch("[^\n]+"))
print(map[vec(2,3)])
printmap(map)
```

## Metastuff

^https://www.lua.org/manual/5.4/manual.html#2.4 Metatables and Metamethods in the manual`.

Most of the metamethods enables syntax like the `+`/`__add` above:
``` repl
print(vec(5, 5) + vec(2, 4))
```

``` run
Dog = {}
function dog(name)
  return setmetatable({ name = name }, Dog)
end
function Dog.__tostring(d) return "a dog called " .. d.name  end
function Dog.__add(a, b) return tostring(a) .. " PLUS " .. tostring(b) end
function Dog.bark(d) print(d.name .. ": Woof") end
deg = dog("Tähti")
```

``` repl
print(deg)
```

Note that the first argument of a binary operation like `__add` might not be the one with the metatable with that `__add` function. While the first operand of the `+` expression takes precedence, the `_add` of the second operand _can_ get called:

``` repl
print(deg + "a string")
print("a string" + deg)
```

Related: Greater than (or equal to) expressions are rewritten to less than (or equal to) expressions before things get to `__lt` (or `__le`).

### "Methods"

Also the metatable is generally only reached _through_ the metamethods and not more directly. If I want something kind of like "methods defined by a class" then I probably wanna go through `__index`. This works:

``` repl
Dog.__index = Dog
deg:bark()
```

This doesn't:

``` repl
Dog.__index = nil
deg:bark()
```

For functionmethodstuff, some things are pretty equivalent:

``` repl
Dog.__index = Dog

function Dog.bark(d) print(d.name .. ": Woof") end
deg:bark()
deg.bark(deg)

function Dog:bark() print(self.name .. ": Woof") end
deg:bark()
deg.bark(deg)

Dog.bark = function(d) print(d.name .. ": Woof") end
deg:bark()
deg.bark(deg)
```

### Default values

`__index` is also sometimes nice for stuff like initializing default values in a table when needed:

``` run
Foo = {}
function foo() return setmetatable({}, Foo) end
function Foo.__index(t, k)
  local res = foo()
  t[k] = res
  return res
end
```

``` repl
local foo = foo()
foo.bar = "blep"
foo.beep.boop = "bap"
print(foo.bar)
print(foo.beep.boop)
```

(`__newindex(t, k, v)` is also a thing. Haven't used it much. I'm a bit uncertain about it and the "`key` must not already be present in table" condition.)

### Writing over, not overwriting

I usually use fairly pure and functional data structures for smol things like vectors and positions, but not for larger things like 2D maps. This leads to sometimes needing to "undo" some mutations. `__index` is sometimes useful. I can keep the original table unchanged while "inheriting" its values through `__index`.

When I'm using the `over` table below, writes modify `over` and reads read from `original` if the key is not present in `over`:

``` repl
local example = [[
+--------+
|        |
+--------+
]]

local original = mappy(example:gmatch("[^\n]+"))
print("original, before:")
printmap(original)

local over = setmetatable({}, { __index = original })
print("over, before:")
printmap(over)

over[vec(2, 2)] = "#"
print("\nover, after:")
printmap(over)
print("original, after:")
printmap(original)
```

## if/else, and/or

if-then-else is statement stuff. For expression stuff, `and` and `or` is nice.

* `nil` and `false` is false, all else is truth
* `true and 4` evaluates to `4`, `false or 2` evaluates to `2`
* etc

``` repl
for n = 1, 100 do
print(
  (n % 3 == 0 and n % 5 == 0 and "fizzbuzz")
  or (n % 3 == 0 and "fizz")
  or (n % 5 == 0 and "buzz")
  or n)
end
```

Oh kay.

