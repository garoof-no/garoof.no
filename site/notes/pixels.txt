# Pixels
:pub ZlDBHH
:blurb Art.
:template js

``` html
<style>
  canvas {
    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAGHaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49J++7vycgaWQ9J1c1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCc/Pg0KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyI+PHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj48cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0idXVpZDpmYWY1YmRkNS1iYTNkLTExZGEtYWQzMS1kMzNkNzUxODJmMWIiIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIj48dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPjwvcmRmOkRlc2NyaXB0aW9uPjwvcmRmOlJERj48L3g6eG1wbWV0YT4NCjw/eHBhY2tldCBlbmQ9J3cnPz4slJgLAAAANklEQVQ4T2N89uzZfwY8QFJSEl0IBTChC5AKRg0YDAYw/v//H286eP78OboQCqDYBaMGDAYDAJKtCsyb8AQCAAAAAElFTkSuQmCC);
  }
  input {
    font-family: Consolas, Menlo, Monaco, "Andale Mono", "Ubuntu Mono", monospace; font-size: 1.05em;;
  }
</style>
<p><canvas id="canvas"></canvas></p>
<ul>
  <li><label>Palette: <input id="palette" style="width: 3rem;"></label></li>
  <li><label>Sprite: <input id="sprite" style="width: 19rem;"></label></li>
</ul>
```

## wth

It's a bad pixel art thing:

* This uses JavaScript so doesn't work if that's disabled here
* It uses the mouse and one (1) mouse button
* You can make an 8 by 8 pixels large sprite with it
* The sprite uses a palette of 4 colours
* The 4-colour palette uses colours from a larger 16-colour one (those 16 colours are from the ^https://www.lexaloffle.com/pico-8.php PICO-8^ palette)
* If the first 2 colours of the 4-colour palette are the same, the first one is treated as transparent
* The palette and sprite graphics are put into the input fields below the editor as hexadecimal strings
* The sprite uses 2 bits for each pixel, so 4 pixels in a byte or 2 pixels in a hexadecimal digit
* The palette uses 4 bits for each color, so 2 colors in a byte or 1 color in a hexadecimal digit
* Using the editor updates the content of the input fields, and writing in the input fields updates the contents of the editor
* Hex strings for sprite and palette can be passed in as query parameters "sprite" and "palette" in the URL
* For converting from other images, see ^./pixels-from-images.txt Pixels from images^

The editor is like a 14 by 8 large grid:

``` drawing
     `1`   `2`   `3`   `4`   `5`   `6`   `7`   `8`   `9`   `10`  `11`  `12`  `13`  `14`
   +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
`1`|     |     |     |     |     |     |     |     |     |     |     |     |     |     |
   |     |     |     |     |     |     |     |     |     |     |     |     |     |     |
   +-                                              |           |                       |
`2`|                                               |           |       `palette`       |
   |                                               |           |                       |
   +-                                              |           +-----------------------+
`3`|                                               |           |                       |
   |                                               |           |                       |
   +-                                              |           |   `selected colour`   |
`4`|                                               |           |                       |
   |                                               |           |                       |
   +-               `drawing area`                 |           +-----------------------+
`5`|                                               |           |                       |
   |                                               |           |                       |
   +-                                              |           |                       |
`6`|                                               |           |                       |
   |                                               |           |                       |
   +-                                              |           |     `full palette`    |
`7`|                                               |           |                       |
   |                                               |           |                       |
   +-                                              |           |                       |
`8`|                                               |           |                       |
   |                                               |           |                       |
   +-----------------------------------------------+-----------+-----------------------+
```

----

Code:

``` run
const canvas = document.querySelector("#canvas");
const scale = 32;
const width = 8 + 2 + 4;
const height = 8;
canvas.width = width  * scale;
canvas.height = height * scale;
const ctx = canvas.getContext("2d");
ctx.scale(scale, scale);
ctx.imageSmoothingEnabled = false;
canvas.oncontextmenu = (e) => e.preventDefault();

const palette = document.querySelector("#palette");
const sprite = document.querySelector("#sprite");

const hexstr = (str) => str.length % 2 == 0 ? str : `${str}0`;

const datafromhex = (str) => {
  const a = Uint8Array.fromHex(hexstr(str));
  const res = [];
  let i = 0;
  for (let y = 0; y < 8; y++) {
    const row = [];
    for (let x = 0; x < 8; x += 4) {
      const v = a[i] || 0;
      row.push(v >> 6);
      row.push((v >> 4) & 0b00000011);
      row.push((v >> 2) & 0b00000011);
      row.push(v & 0b00000011);
      i++;
    }
    res.push(row);
  }
  return res;
};

const hexdata = (data) => {
  const res = new Uint8Array(8 * 8 / 4);
  let i = 0;
  data.forEach((row) => {
    for (let x = 0; x < row.length; x += 4) {
       res[i] = (row[x] << 6) | (row[x + 1] << 4) | (row[x + 2] << 2) | row[x + 3];
       i++;
    }
  });
  return res.toHex();
};

const palfromhex = (str) => {
  const a = Uint8Array.fromHex(hexstr(str));
  const res = [];
  let i = 0;
  for (let x = 0; x < 8; x++) {
    const v = a[i] || 0;
    res.push(v >> 4);
    res.push(v & 0b00001111);
    i++;
  }
  return res;
};

const hexpal = (pal) => {
  const res = new Uint8Array(4 / 2);
  let i = 0;
  for (let x = 0; x < pal.length; x += 2) {
     res[i] = (pal[x] << 4) | pal[x + 1];
     i++;
  }
  return res.toHex();
};

const params = new URLSearchParams(window.location.search);
let data = datafromhex(params.has("sprite") ? params.get("sprite") : "00410455106610551554155415541004");
const fullpal =
  [
    "#000000", "#1D2B53", "#7E2553", "#008751",
    "#AB5236", "#5F574F", "#C2C3C7", "#FFF1E8",
    "#FF004D", "#FFA300", "#FFEC27", "#00E436",
    "#29ADFF", "#83769C", "#FF77A8", "#FFCCAA"];
let pal = palfromhex(params.has("palette") ? params.get("palette") : "11c5");

let color = 1;

const rendercanvas = () => {
  const transparent = pal[0] === pal[1];
  ctx.clearRect(0, 0, width, height);
  data.forEach(
    (row, y) => row.forEach(
        (i, x) => {
          if (i > 0 || !transparent) {
            ctx.fillStyle = fullpal[pal[i]];
            ctx.fillRect(x, y, 1, 1);
          }
        }));
  if (transparent) {
    const unused = [];
    fullpal.forEach((_, i) => {
      if (!pal.includes(i)) {
        unused.push(i);
      }
    });
    for (let y = 0; y < 8; y++) {
      ctx.fillStyle = fullpal[unused[y % 2 === 0 ? 0 : 1]];
      ctx.fillRect(8, y, 1, 1);
    }
  }
  pal.forEach((c, i) => {
    ctx.fillStyle = fullpal[c];
    ctx.fillRect(10 + i, 0, 1, 2);
  });
  ctx.fillStyle = fullpal[pal[color]];
  ctx.fillRect(10, 2, 4, 2);
  fullpal.forEach((c, i) => {
    ctx.fillStyle = c;
    const x = i % 4;
    const y = Math.trunc(i / 4);
    ctx.fillRect(10 + x, 4 + y, 1, 1);
  });
};

const render = () => {
  sprite.value = hexdata(data);
  palette.value = hexpal(pal);
  rendercanvas();
};
render();

const bound = (i, limit) => {
  const res = Math.trunc(i / scale);
  if (res < 0) return 0;
  if (res >= limit) return limit - 1;
  return res;
};

const onmouse = (e) => {
  const x = bound(e.offsetX);
  const y = bound(e.offsetY);
  if (e.buttons === 1) {
    if (x < 8) {
      data[y][x] = color;
    } else if (x < 10) {
      return;
    } else if (y < 2) {
      color = x - 10;
    } else if (y < 4) {
      return;
    } else {
      pal[color] = ((y - 4) * 4) + (x - 10)
    }
    render();
  }
};

canvas.onmousedown = onmouse;
canvas.onmousemove = onmouse;

palette.oninput = () => {
  pal = palfromhex(palette.value);
  rendercanvas();
}
sprite.oninput = () => {
  data = datafromhex(sprite.value);
  rendercanvas();
}
```

