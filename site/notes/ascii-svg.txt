# Attempting to SVG some ASCII art diagrams
:todo under construction
:template lua

I made thing for this website a little while ago. Thing that lets me render a diagram made with ASCII art as SVG on a webpage. So I can do:

````
``` drawing
.-------.   .-------.
| hello +-->| world |
'-------'   '-------'
```
````

And get:

``` drawing
.-------.   .-------.
| hello +-->| world |
'-------'   '-------'
```

I looked a bit around before I made it. I tend to look for something like, some ways of thinking about the problem and maybe dividing it into subproblems, different approaches, tradeoffs, maybe some "patterns." I don't usually find what I'm looking for though. Found some existing solutions, but couldn't be bothered digging into them and figuring out what the important ideas were etc. So I just I ended up _doing something:_

## Line segments and shapes

One thought I had was something like: If you draw a rectangle with ASCII art, maybe the thing should figure out that it's a rectangle and make an SVG `<rect>`, and so on. The alternative seemed to be to process one character at a time: If the character's a hyphen, we make a little horizontal SVG `<line>`, and so forth. I think it sounds nice to have an SVG with reasonably few, uh, "appropriate" SVG shapes in it. And less nice to have one with a ton of tiny lines that happen to form shapes.

So I had some thoughts like, if I find a hyphen, should I like try to follow that line to see what shape it makes? And then, how do I deal with this-or-that? Should I "consume" a character once I've processed it as part of a shape? What if it's part of another shape as well? How do I know e.g. which way to follow it at the plus sign on the hello box there? Bunch of stuff that sounded too complicated for _my_ head.

So eh. Decided to do the one character at a time thing. If I did that and also had some "line joining" machinery, then I could probably keep things fairly simple in my head and also keep the SVG from getting too bad.

``` drawing
.-----------.                 .--------------.
|   line    |                 | one char at  |
|  joining  |                 |   a time     |
| machinery |                 |  processor   |
'-----------'                 '--------------'
     |                               |
     |      add((1, 1), (2, 2))      |
     |<------------------------------|
     |      add((2, 2), (2, 1))      |
     |<------------------------------|
     |      add((3, 3), (4, 4))      |
     |<------------------------------|
     |                               |
     |         lines plox            |
     |<------------------------------|
     | { (1, 1), (2, 2), (2, 1) }    |
     | { ((3, 3), (4, 4)) }          |
     |------------------------------>|
     |                               |
     |                               |
```

Like if you added a line from (1, 1) to (2, 2) and then a line from (2, 2) to (2, 1), the machinery would join those together. If you then added a line from (3, 3) to (4, 4), that would not connect to any existing (poly)line, so you'd end up with two "shapes:" One polyline from (1, 1) to (2, 2) to (2, 1), and one line from (3, 3) to (4, 4).

## Drawing some stuff

We wanna draw some SVG stuff. We need points:

``` run
Point = {}
allpoints = setmetatable({}, { __mode = "kv" })
function point(x, y)
  local key = x .. "," .. y
  local res = allpoints[key]
  if res then return res end
  res = setmetatable({ x = x, y = y }, Point)
  allpoints[key] = res
  return res
end

function Point:__add(other)
  return point(self.x + other.x, self.y + other.y)
end

function Point:__tostring()
  return "(" .. self.x ", " .. self.y .. ")"
end

U, R, D, L = point(0, -1), point(1, 0), point(0, 1), point(-1, 0)
```

And something for making lines between points:

``` run
xscale, yscale = 1, 1
function lineSvg(tag, color, points)
  local res = { '<', tag, ' stroke="', color, '" points="' }
  for p in points do
    table.insert(res, " " .. p.x * xscale .. "," .. p.y * yscale)
  end
  table.insert(res, '" />')
  return table.concat(res)
end
```

Because reasons, `lineSvg` takes an iterator function as its `points` argument, instead of e.g. a table. We'll make a helper function for testing:

``` run
function it(list)
  local i = 0
  return function()
    i = i + 1
    return list[i]
  end
end
```

Can make a drawing now:

``` repl
local list1 = { point(10, 10), point(110, 10), point(110, 110) }
local list2 = { point(10, 10), point(10, 110), point(110, 110) }
local list3 = { point(30, 30), point(100, 60), point(20, 90) }
web.html(
  '<svg width="120" height="120">' ..
  lineSvg("polyline", "white", it(list1)) ..
  lineSvg("polyline", "black", it(list2)) ..
  lineSvg("polygon", "yellow", it(list3)) ..
  '<svg>'
)
```

Great.

## Map of chars

We wanna turn a string into a data structure that lets us treat things as kind of a 2D map. The details aren't terribly important, but here's some thing:

``` run
function mapfrom(str)
  local chars = {}
  local res = { w = 0, h = 0, chars = chars }
  local x, y = 0, 0
  for c in str:gmatch(".") do
    if c == "\n" then
      y = y + 1
      x = 0
    else
      if c ~= " " then
        chars[point(x, y)] = c
        res.w = math.max(res.w, x)
      end
      x = x + 1
    end
  end
  res.h = y
  function res.at(p)
    return chars[p]
  end
  return res
end
```

We'll test it somewhat:

``` run
teststring = [[
+----------+
| +--+ +-+ |
| |  | +-+ |
| |  +-----+
+-+--+     | 
+----------+
]]
```

``` repl
map = mapfrom(teststring)
print(map.at(point(0, 0)))
print(map.at(point(1, 0)))
print(map.at(point(0, 1)))
print(map.at(point(1, 1)))
print(map.at(point(0, 3)))
print(map.at(point(4, 1)))
print(map.at(point(5, 1)))
```

Seems fine.

## Processing chars

We'll deal with the line joining machinery later. In order to have something to program against, we'll make something that doesn't actually join any lines:

``` run
function nojoining()
  local res = {}
  function res.add(from, to)
    table.insert( res, { points = function() return it({ from, to }) end })
  end
  return res
end
```

Okay. I dunno. I like to think of each character as occupying some space within the larger map, but kind of having its own local coordinates. Characters are often roughly twice as tall as they are wide, particularly in monospacey ASCII art stuff, so e.g. 2 by 4:

``` drawing
+-+-+
+-+-+
+-+-+
+-+-+
+-+-+
```

So then we can think of the top left of the character as (0, 0), the middle as (1, 2), the bottom right as (2, 4), and so on. When we're processing a character, we can have a helper function that translates coordinates like those into global coordinates. We'll make a helper function function:

``` run
function halphalp(lines, p)
  local off = point(p.x * 2, p.y * 4)
  return function(from, to)
    lines.add(off + from, off + to)
  end
end
```

Let's turn some characters into lines. We turn hyphens and pipes into horizontal and vertical lines. We can imagine expanding this in various ways, but the fundamentals are there: Adding lines, possibly depending on neighbouring characters.

``` run
function makelines(map)
  local res = lines()
  for p, c in pairs(map.chars) do
    local add = halphalp(res, p)
    if c == "|" then
      add(point(1, 0), point(1, 4))
    elseif c == "-" then
      add(point(0, 2), point(2, 2))
    elseif c == "+" then
      local l = map.at(p + L)
      local r = map.at(p + R)
      local u = map.at(p + U)
      local d = map.at(p + D)

      if l == "-" or l == "+" then
        add(point(0, 2), point(1, 2))
      end
      if r == "-" or r == "+" then
        add(point(1, 2), point(2, 2))
      end
      if u == "|" or u == "+" then
        add(point(1, 0), point(1, 2))
      end
      if d == "|" or d == "+" then
        add(point(1, 2), point(1, 4))
      end
    end
  end
  return res
end
```

``` run
function makeSvg(map)
  local lines = makelines(map)
  local w = (map.w + 1) * 2
  local h = (map.h + 1) * 4
  local res = { '<svg width="' .. w * xscale .. '" height="' .. h * yscale .. '">' }
  for _, l in ipairs(lines) do
     if l.points then
       local tag = l.closed and "polygon" or "polyline"
       table.insert(res, lineSvg(tag, color(), l.points()))
     end
  end
  table.insert(res, '</svg>')
  return table.concat(res)
end
```

``` repl
lines = nojoining
function color() return "white" end
xscale, yscale = 12, 12
web.html(makeSvg(mapfrom(teststring)))
```

## Lots of tiny lines

Okay so just to _illustrate_ that we're drawing very many tiny lines this way, we'll mess with the colours:

``` run
coloridx = 0
colors = { "white", "black", "yellow" }
function colorcycler()
  coloridx = coloridx + 1
  local res = colors[coloridx]
  if coloridx == #colors then coloridx = 0 end
  return res
end
```

``` repl
lines = nojoining
color = colorcycler
xscale, yscale = 12, 12
web.html(makeSvg(mapfrom(teststring)))
```

## Line joining machinery

A few things:

* Want lines that we can extend in either direction
* When we add a line, we must be able to figure out what to do: Add a new line, extend an existing, join two lines, or join a line to itself (close it and make a polygon instead of a polyline)
* Also also like, when we figure out what to do we wanna like, do that thing

For the extending in either direction part: One way to do it is to just have two array-like tables. Like a polyline with six points could look like this:

``` drawing
 first       last
  2 1       1 2 3 4
 +-+-+     +-+-+-+-+
 +-+-+     +-+-+-+-+
```

Like, if a polyline consists of one 2-element array (`first`) and one 4-element array (`last`), the full polyline would go like:

* `first[2]`, `first[1]`, `last[1]`, `last[2]`, `last[3]`, `last[4]`
* Or, in the other direction: `last[4]`, `last[3]`, `last[2]`, `last[1]`, `first[1]`, `first[2]`

So you kind of count down in one array and then up in the other one in order to get all the points in a reasonable order. Makes it so you can always add new points to the end of one of the arrays in order to extend the polyline.

Some supporty helpy stuff. If a "half" of a polyline is an array connected to the other half, we can make an iterator function that counts down through the half we start with and then up through the one that's connected to:

``` run
function halfandhalf(half)
  local other = half.other
  local current
  local i = #half
  local function last()
    local res = other[i]
    i = i + 1
    if i > #other then current = nil end
    return res
  end
  local function first()
    local res = half[i]
    if i == 1 then current = last
    else i = i - 1
    end
    return res
  end
  current = first
  return function()
    return current and current()
  end
end
```

An test:

``` repl
local other = { "c", "d", "e", "f" }
local half = { "b", "a", other = other }
other.other = half
print("from one side:")
for c in halfandhalf(half) do print(c) end
print("\nfrom the other:")
for c in halfandhalf(other) do print(c) end
```

Later on, if we're extending a "half" and we're not changing direction, we can move the end of the line instead of adding a new point to it. Some direction helper stuff:

``` run
function samedir(a, b)
  if a.x == b.x and a.y == b.y then
    return true
  elseif a.x == 0 and b.x == 0 then
    return (a.y > 0 and b.y > 0) or (a.y < 0 and b.y < 0)
  elseif a.y == 0 and b.y == 0 then
    return (a.x > 0 and b.x > 0) or (a.x < 0 and b.x < 0)
  else
    return false
  end
end

function dir(from, to)
  return point(to.x - from.x, to.y - from.y)
end
```

So uh, the joining machinery then. Same interface as `nojoining`. We want to create something that has an `add` function that takes two points. And after adding a bunch of stuff, we want the thing to be an array with a bunch of stuff. If an element in the array has a `points` function, then we can call that to get an iterator function for the points in a polyline/-gon.

Internally, it will also keep track of where things are `extendible`. Whenever something is added, the two points are looked up in `extendible`. The lookup returns the "half" that can be extended, if any.

* If neither points is extendible, a new polyline is added with `line`
* If one point is extendible, then the half we found is extended wiht `extend`
* If both points are extendible, the two things we found are joined

A polyline is joined to itself (if the two havles we found are each others `other`s) by closing it (turning it into a polygon). A polyline is is joined to another by removing the one with the fewest points and axtending the one we're keeping with all the points from the one we're removing.

``` run
function joining()

  local lines = {}
  local extendible = {}

  local function line(from, to)
    local meta = { }
    local half = { from, dir = dir(to, from), meta = meta }
    local other = { to, other = half, dir = dir(from, to), meta = meta }
    half.other = other
    function meta.points() return halfandhalf(half) end
    table.insert(lines, meta)
    extendible[from] = half
    extendible[to] = other
  end

  local function extend(half, point)
    local i = #half
    local prev = half[i]
    extendible[prev] = nil
    extendible[point] = half

    local newdir = dir(prev, point)
    if not samedir(newdir, half.dir) then
      i = i + 1
    end  
    half[i] = point
    half.dir = newdir
  end

  local function unstend(half)
    extendible[half[#half]] = nil
  end

  local function join(first, last)
    if first == last then
      error("oh no")
    elseif first.other == last then
      first.meta.closed = true
      unstend(first)
      unstend(last)
      return
    else
      local flen = #first + #first.other
      local llen = #last + #last.other
      local keep, remove
      if flen >= llen then keep, remove = first, last
      else keep, remove = last, first end
      unstend(remove)
      unstend(remove.other)
      remove.meta.points = nil
      for p in halfandhalf(remove) do
        extend(keep, p)
      end
    end
  end

  function lines.add(from, to)
    local first = extendible[from]
    local last = extendible[to]
    if first and last then
      join(first, last)
    elseif first then
      extend(first, to)
    elseif last then
      extend(last, from)
    else
      line(from, to)
    end
  end
  return lines
end
```

Let's test:

``` repl
lines = joining
color = colorcycler
xscale, yscale = 12, 12
web.html(makeSvg(mapfrom(teststring)))
```

Fewer line elements :)

